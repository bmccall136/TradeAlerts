import os
import subprocess
import sqlite3
import threading
import time
import platform
from pathlib import Path
from datetime import datetime, timedelta
from functools import wraps

from flask import (
    Flask, request, render_template,
    redirect, url_for, flash, jsonify,
    Response
)
# ── service imports for backtest ─────────────────────────────────────────────
from services.scanner_backtest_service import backtest_scanner
from services.market_service           import get_symbols
# 1) Instantiate your app
app = Flask(__name__)
# ── Add this so flash() will work ───────────────────
app.secret_key = os.environ.get('PokeChop!', 'PokeChop!')
BACKTEST_DB = os.path.join(os.getcwd(), 'backtest.db')

# 2) BacktestSettings + extractor
from collections import namedtuple
BacktestSettings = namedtuple('BacktestSettings', [
    # … existing fields …,
    'single_entry_only',
    'use_trailing_stop',
    'trailing_stop_pct',
    'sell_after_days',
    'start_date','end_date','starting_cash','max_per_trade',
    'timeframe','trailing_stop_pct','sell_after_days',
    'sma_on','rsi_on','macd_on','bb_on','vol_on','vwap_on','news_on',
    'sma_length','rsi_len','rsi_overbought','rsi_oversold',
    'macd_fast','macd_slow','macd_signal',
    'bb_length','bb_std','vol_multiplier','vwap_threshold',
])
def extract_backtest_settings(args):
    return BacktestSettings(
        start_date        = args.get('start_date',     '2023-01-01'),
        end_date          = args.get('end_date',       '2024-01-01'),
        starting_cash     = int(args.get('starting_cash', 10000)),
        max_per_trade     = int(args.get('max_per_trade',    1000)),
        timeframe         = args.get('timeframe',       '6mo'),
        trailing_stop_pct = float(args.get('trailing_stop_pct', 0.05)),
        sell_after_days   = int(args.get('sell_after_days')) if args.get('sell_after_days') else None,
        sma_on           = 'sma_on'  in args,
        rsi_on           = 'rsi_on'  in args,
        macd_on          = 'macd_on' in args,
        bb_on            = 'bb_on'   in args,
        vol_on           = 'vol_on'  in args,
        vwap_on          = 'vwap_on' in args,
        news_on          = 'news_on' in args,
        sma_length       = int(args.get('sma_length',      20)),
        rsi_len          = int(args.get('rsi_len',         14)),
        rsi_overbought   = int(args.get('rsi_overbought',  70)),
        rsi_oversold     = int(args.get('rsi_oversold',    30)),
        macd_fast        = int(args.get('macd_fast',       12)),
        macd_slow        = int(args.get('macd_slow',       26)),
        macd_signal      = int(args.get('macd_signal',      9)),
        bb_length        = int(args.get('bb_length',       20)),
        bb_std           = float(args.get('bb_std',         2.0)),
        vol_multiplier   = float(args.get('vol_multiplier', 1.0)),
        vwap_threshold   = float(args.get('vwap_threshold', 0.0)),
        single_entry_only  = 'single_entry_only'  in args,
        use_trailing_stop  = 'use_trailing_stop'  in args,
        trailing_stop_pct  = float(args.get('trailing_stop_pct', 0.05)),
        sell_after_days    = int(args.get('sell_after_days')) if args.get('sell_after_days') else None,

    )

# 3) Register the /backtest route
@app.route('/backtest')
def backtest_view():
    conn = sqlite3.connect(BACKTEST_DB)
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute('SELECT id FROM backtest_runs ORDER BY id DESC LIMIT 1')
    row = c.fetchone()
    if not row:
        trades, summary = [], {
            'total_pnl':0.0,'num_trades':0,'wins':0,'losses':0,'by_symbol':{}
        }
    else:
        run_id = row['id']
        c.execute("""
            SELECT symbol, action, trade_time AS date, qty, price, pnl
              FROM backtest_trades
             WHERE run_id = ?
             ORDER BY id
        """, (run_id,))
        trades = [dict(r) for r in c.fetchall()]
        total_pnl = sum((r['pnl'] or 0) for r in trades)
        num_trades = len(trades)
        wins = sum(1 for r in trades if (r['pnl'] or 0) > 0)
        losses = sum(1 for r in trades if (r['pnl'] or 0) < 0)
        by_symbol = {}
        for r in trades:
            by_symbol.setdefault(r['symbol'], 0.0)
            by_symbol[r['symbol']] += (r['pnl'] or 0.0)
        summary = {
            'total_pnl': round(total_pnl,2),
            'num_trades': num_trades,
            'wins': wins,
            'losses': losses,
            'by_symbol': by_symbol
        }
    conn.close()
    settings = extract_backtest_settings(request.args)
    return render_template(
        'backtest.html',
        trades=trades,
        summary=summary,
        settings=settings,
        net_return=summary['total_pnl']
    )

# 4) Now bring in your Basic Auth and all the other @app.route handlers below…

USERNAME = os.environ.get("BASIC_AUTH_USER", "admin")
PASSWORD = os.environ.get("BASIC_AUTH_PASS", "Shadow!")

def check_auth(user, pw):
    return user == USERNAME and pw == PASSWORD

def authenticate():
    return Response(
        "⛔ Authentication Required", 401,
        {'WWW-Authenticate': 'Basic realm="Login Required"'}
    )

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            return authenticate()
        return f(*args, **kwargs)
    return decorated

def scanner_loop():
    global scanner_active
    scanner_active = True
    while True:
        try:
            from scanner import run_scan
            run_scan()
            print("[Scanner] ✅ Ran scan loop")
        except Exception as e:
            print(f"[Scanner] ❌ Error: {e}")
        time.sleep(60)

        
@app.route("/start_scanner", methods=["POST"])
def start_scanner():
    if platform.system() == "Windows":
        subprocess.Popen(["start", "start_scanner.bat"], shell=True)
    return redirect(url_for('index'))

@app.route("/stop_scanner", methods=["POST"])
def stop_scanner():
    if platform.system() == "Windows":
        subprocess.call(["stop_scanner.bat"], shell=True)
    return redirect(url_for('index'))

@app.route('/run-checkpoint')
def run_checkpoint():
    bat_path = os.path.join(os.getcwd(), 'checkpoint.bat')  # Adjust path if needed
    try:
        subprocess.Popen(['cmd.exe', '/c', 'start', 'cmd.exe', '/k', bat_path], shell=True)
        return redirect(url_for('index'))
    except Exception as e:
        return f"Error executing batch: {e}", 500
### ────────────── ALERTS (LIST & CLEAR) ────────────── ###

@app.route('/nuke_db', methods=['POST'])
def nuke_db():
    try:
        result = subprocess.run(
            ['python', 'init_alerts_db.py'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            flash('✅ Database nuked and recreated!', 'success')
        else:
            flash(f'❌ Nuke failed: {result.stderr}', 'danger')
    except Exception as e:
        flash(f'❌ Error nuking DB: {e}', 'danger')
    return redirect(url_for('index'))


@app.route('/clear_all', methods=['POST'])
def clear_all_alerts():
    print("✅ /clear_all route hit")
    conn = sqlite3.connect(DB_PATH)
    conn.execute("DELETE FROM alerts")
    conn.commit()
    conn.close()
    return redirect(url_for('index'))

@app.route('/clear/<int:id>', methods=['POST'])
def clear_alert(id):
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.execute("DELETE FROM alerts WHERE id=?", (id,))
        conn.commit()
        conn.close()
        print(f"✅ Cleared alert #{id}")
        return jsonify({"success": True})
    except Exception as e:
        print(f"❌ Error clearing alert #{id}: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/launch_auth', methods=['POST'])
def launch_auth():
    try:
        subprocess.Popen(
            ['start', 'cmd', '/k', 'python', 'etrade_auth_flow.py'],
            shell=True
        )
        flash('🔑 E*TRADE Auth flow launched in new window.', 'info')
    except Exception as e:
        flash(f'❌ Error launching E*TRADE Auth: {e}', 'danger')
    return redirect(url_for('index'))
# ── 2) run_backtest: wipe + run + log to DB ────────────────────────────────────

# at top of Dashboard.py
BACKTEST_DB = os.path.join(os.getcwd(), 'backtest.db')


# ────────────────────────────────────────────────────────
# 2) RUN BACKTEST (wipe + run + log)
# ────────────────────────────────────────────────────────

@app.route('/run_backtest', methods=['POST'])
def run_backtest():
    # 1) Parse settings and load symbols
    settings = extract_backtest_settings(request.form)
    symbols  = get_symbols(simulation=True)

    # 2) Reinitialize DB
    subprocess.run(['python', 'init_backtest_db.py'], check=True)

    # 3) Backtest each symbol with all kwargs
    for sym in symbols:
        backtest_scanner(
            symbol            = sym,
            start_date        = settings.start_date,
            end_date          = settings.end_date,
            initial_cash      = settings.starting_cash,
            max_trade_amount  = settings.max_per_trade,
            timeframe         = settings.timeframe,

            sma_on            = settings.sma_on,
            sma_length        = settings.sma_length,

            rsi_on            = settings.rsi_on,
            rsi_len           = settings.rsi_len,
            rsi_overbought    = settings.rsi_overbought,
            rsi_oversold      = settings.rsi_oversold,

            macd_on           = settings.macd_on,
            macd_fast         = settings.macd_fast,
            macd_slow         = settings.macd_slow,
            macd_signal       = settings.macd_signal,

            bb_on             = settings.bb_on,
            bb_length         = settings.bb_length,
            bb_std            = settings.bb_std,

            vol_on            = settings.vol_on,
            vol_multiplier    = settings.vol_multiplier,

            vwap_on           = settings.vwap_on,
            vwap_threshold    = settings.vwap_threshold,

            news_on           = settings.news_on,

            log_to_db         = True
        )

    flash('✅ Backtest run complete!', 'success')
    return redirect(url_for('backtest_view', **request.form))





@app.route('/reset_backtest', methods=['POST'])
def reset_backtest():
    try:
        subprocess.run(['python','init_backtest_db.py'], check=True)
        flash('✅ Backtest DB nuked and recreated!', 'success')
    except Exception as e:
        flash(f'❌ Backtest reset failed: {e}', 'danger')
    return redirect(url_for('backtest_view'))


@app.route('/config')
def config():
    config = {}
    config_clean = {
        k: str(v) if isinstance(v, timedelta) else v
        for k, v in config.items()
    }
    return render_template('config.html', config=config_clean)


### ────────────── SIMULATION ────────────── ###

@app.route('/reset_simulation', methods=['POST'])
def reset_simulation():
    success = nuke_simulation_db()
    if success:
        return "Simulation reset!", 200
    else:
        return "Failed to reset simulation database.", 500


@app.route('/simulation')
def simulation():
    # Default fallback values if something goes wrong
    cash               = 0.0
    unrealized_pnl     = 0.0
    realized_pnl       = 0.0
    formatted_holdings = []
    formatted_trades   = []

    try:
        # 1) Current cash & realized P/L
        cash          = get_cash()
        realized_pnl  = get_realized_pl()

        # 2) Gather and format holdings
        raw_holdings = get_holdings()
        unrealized_pnl = 0.0
        for h in raw_holdings:
            unrealized_pnl += h['total_gain']
            formatted_holdings.append({
                'symbol':     h['symbol'],
                'last_price': h['last_price'],
                'change':     h['change'],
                'change_pct': h['change_pct'],
                'qty':        h['qty'],
                'price_paid': h['price_paid'],
                'day_gain':   h['day_gain'],
                'total_gain': h['total_gain'],
                'value':      h['value']
            })

        # 3) Gather and format trade history
        raw_trades = get_trades()
        for t in raw_trades:
            pl_display = f"${t['pnl']:.2f}" if t['pnl'] is not None else "-"
            formatted_trades.append({
                'time':   t['trade_time'],
                'symbol': t['symbol'],
                'action': t['action'],
                'qty':    t['qty'],
                'price':  f"${t['price']:.2f}",
                'pl':     pl_display
            })

    except Exception as e:
        import traceback; traceback.print_exc()
        print(f"[Simulation Error] {e}")

    return render_template(
        'simulation.html',
        cash=cash,
        unrealized_pnl=unrealized_pnl,
        realized_pnl=realized_pnl,
        holdings=formatted_holdings,
        history=formatted_trades
    )


@app.route("/simulation/buy", methods=["POST"])
def simulation_buy():
    from flask import current_app
    try:
        data   = request.get_json(force=True)
        symbol = data.get("symbol")
        qty    = int(data.get("qty", 1))

        # 1) Validate
        if not symbol or qty <= 0:
            return jsonify(success=False, error="Invalid symbol or quantity"), 400

        # 2) Fetch current price from E*TRADE API
        from services.etrade_service import fetch_etrade_quote
        quote_data = fetch_etrade_quote(symbol)
        if isinstance(quote_data, dict):
            # tweak these keys if your API returns different field names
            price = float(
                quote_data.get("lastTrade") or
                quote_data.get("closePrice") or
                0
            )
        else:
            price = float(quote_data)

        current_app.logger.info(f"💲 Using E*TRADE price for {symbol}: {price}")

        # 3) Perform the buy with the live price
        result = buy_stock(symbol, qty, price)
        if result:
            return jsonify(success=True), 200
        else:
            current_app.logger.error("❌ buy_stock() returned False")
            return jsonify(success=False, error="buy_stock() returned False"), 500

    except Exception as e:
        current_app.logger.exception("🚨 Exception in simulation_buy")
        return jsonify(success=False, error=str(e)), 500


@app.route("/simulation/sell", methods=["POST"])
def simulation_sell():
    data = request.get_json()
    symbol = data.get("symbol")
    qty    = int(data.get("qty", 0))
    if not symbol or qty <= 0:
        return jsonify({"error": "Invalid symbol or quantity"}), 400

    try:
        price = get_etrade_price(symbol)
        sell_stock(symbol, qty, price)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

    return jsonify({
        "success": True,
        "cash": get_cash(),
        "realized_pl": get_realized_pl()
    }), 200


from flask import request, redirect, url_for, render_template
from services.alert_service import (
    get_all_indicator_settings,
    update_indicator_settings,
    get_alerts
)

@app.route("/", methods=["GET"])
def index():
    # 1) Load persisted settings (or defaults if first run)
    settings = get_all_indicator_settings()

    # 2) If the user clicked “Apply” (i.e. there's any query-string),
    #    merge those overrides into `settings`, persist, then redirect.
    if request.args:
        # Boolean toggles: checked ⇒ present in request.args
        for toggle in (
            "sma_on","rsi_on","macd_on","bb_on","vol_on",
            "vwap_on","news_on","rsi_slope_on","macd_hist_on","bb_breakout_on"
        ):
            settings[toggle] = (toggle in request.args)

        # Numeric filters: parse back out of the query string
        for field in (
            "sma_length","rsi_len","rsi_overbought","rsi_oversold",
            "macd_fast","macd_slow","macd_signal",
            "bb_length","bb_std","vol_multiplier","vwap_threshold"
        ):
            if field in request.args:
                val = request.args[field]
                # floating‐point for the ones that need it:
                if field in ("bb_std","vol_multiplier","vwap_threshold"):
                    settings[field] = float(val)
                else:
                    settings[field] = int(val)

        # Persist and clean‐URL redirect
        update_indicator_settings(settings)
        return redirect(url_for("index"))

    # 3) No query‐string ⇒ build your alerts with current settings,
    #    update match_count, persist it, then render.
    alerts = get_alerts()
    settings["match_count"] = len(alerts)
    update_indicator_settings(settings)

    return render_template(
        "alerts.html",
        alerts=alerts,
        settings=settings,
        match_count=settings["match_count"]
    )




@app.before_request
def secure_everything():
    if request.path == "/health":
        return  # Allow unauthenticated access to /health
    return require_auth(lambda: None)()  # Apply auth to all other routes


if __name__ == "__main__":
    # Local dev only
    threading.Thread(target=scanner_loop, daemon=True).start()
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)




