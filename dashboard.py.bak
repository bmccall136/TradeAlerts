# File: dashboard.py
from services.alert_service import (
    save_indicator_settings,
    get_all_indicator_settings,
    get_alerts,
)
from pathlib import Path
import os
import subprocess
import sqlite3
from datetime import datetime, timedelta

from flask import (
    Flask, render_template, redirect, url_for,
    request, flash, jsonify
)

# ALERTS & INDICATOR SETTINGS
from services.alert_service import (
    save_indicator_settings,
    get_all_indicator_settings,
    get_alerts
)

# NEWS
from services.news_service import fetch_latest_headlines, fetch_sentiment_for

# E*TRADE
from services.etrade_service import get_etrade_price

# SIMULATION
from services.simulation_service import (
    buy_stock,
    get_holdings,
    get_cash,
    get_realized_pl,
    get_trades,
    sell_stock,
    nuke_simulation_db   # if you need to reset simulation DB
)

# BACKTEST
from services.backtest_service import backtest

# MARKET SCANNER
from services.market_service import analyze_symbol, get_symbols


app = Flask(__name__)
app.secret_key = "replace_with_your_secret_key"

DB_PATH  = 'alerts.db'
SIM_DB   = 'simulation.db'  # Must match SIM_DB in simulation_service.py

@app.route('/run-checkpoint')
def run_checkpoint():
    bat_path = os.path.join(os.getcwd(), 'checkpoint.bat')  # Adjust path if needed
    try:
        subprocess.Popen(['cmd.exe', '/c', 'start', 'cmd.exe', '/k', bat_path], shell=True)
        return redirect(url_for('index'))
    except Exception as e:
        return f"Error executing batch: {e}", 500

### ────────────── PRELOAD BACKTEST DATA (optional) ────────────── ###
# If you want to run a backtest when the server starts, uncomment below:
# trades, pnl = backtest("AAPL", "2024-01-01", "2024-06-01", initial_cash=10000)
# You can then pass `trades` and `pnl` into a template or store them.


### ────────────── ALERTS (LIST & CLEAR) ────────────── ###

@app.route('/nuke_db', methods=['POST'])
def nuke_db():
    try:
        result = subprocess.run(
            ['python', 'init_alerts_db.py'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            flash('✅ Database nuked and recreated!', 'success')
        else:
            flash(f'❌ Nuke failed: {result.stderr}', 'danger')
    except Exception as e:
        flash(f'❌ Error nuking DB: {e}', 'danger')
    return redirect(url_for('index'))


@app.route('/clear_all', methods=['POST'])
def clear_all_alerts():
    print("✅ /clear_all route hit")
    conn = sqlite3.connect(DB_PATH)
    conn.execute("DELETE FROM alerts")
    conn.commit()
    conn.close()
    return redirect(url_for('index'))

@app.route('/clear/<int:id>', methods=['POST'])
def clear_alert(id):
    conn = sqlite3.connect(DB_PATH)
    conn.execute("DELETE FROM alerts WHERE id=?", (id,))
    conn.commit()
    conn.close()
    flash(f'ℹ️ Alert #{id} cleared.', 'info')
    return redirect(url_for('index'))


@app.route('/buy/<symbol>', methods=['POST'])
def buy_stock_route(symbol):
    # “Buy” route just flashes a message on the Alerts page
    flash(f'🟢 Simulated BUY for {symbol}', 'success')
    return redirect(url_for('index'))


@app.route('/launch_auth', methods=['POST'])
def launch_auth():
    try:
        subprocess.Popen(
            ['start', 'cmd', '/k', 'python', 'etrade_auth_flow.py'],
            shell=True
        )
        flash('🔑 E*TRADE Auth flow launched in new window.', 'info')
    except Exception as e:
        flash(f'❌ Error launching E*TRADE Auth: {e}', 'danger')
    return redirect(url_for('index'))


### ────────────── BACKTEST VIEW ────────────── ###

from flask import request, render_template

@app.route('/backtest', methods=['GET', 'POST'])
def backtest_view():
    settings = {
        'sma_on': 'sma_on' in request.args,
        'rsi_on': 'rsi_on' in request.args,
        'macd_on': 'macd_on' in request.args,
        'bb_on': 'bb_on' in request.args,
        'vol_on': 'vol_on' in request.args,
        'vwap_on': 'vwap_on' in request.args,
        'news_on': 'news_on' in request.args,
        'sma_length': int(request.args.get('sma_length', 20)),
        'rsi_len': int(request.args.get('rsi_len', 14)),
        'rsi_overbought': int(request.args.get('rsi_overbought', 70)),
        'rsi_oversold': int(request.args.get('rsi_oversold', 30)),
        'macd_fast': int(request.args.get('macd_fast', 12)),
        'macd_slow': int(request.args.get('macd_slow', 26)),
        'macd_signal': int(request.args.get('macd_signal', 9)),
        'bb_length': int(request.args.get('bb_length', 20)),
        'bb_std': float(request.args.get('bb_std', 2.0)),
        'vol_multiplier': float(request.args.get('vol_multiplier', 1.5)),
        'vwap_threshold': float(request.args.get('vwap_threshold', 1.0)),
        'initial_cash': float(request.args.get('initial_cash', 10000)),
        'trade_limit': float(request.args.get('trade_limit', 1000)),
        'timeframe': request.args.get('timeframe', '6mo')
    }

    # Temporary backtest call for a hardcoded symbol, e.g., 'AAPL'
    trades, net_return = backtest(
        symbol='AAPL',
        start_date='2023-01-01',
        end_date='2023-12-31',
        initial_cash=settings['initial_cash'],
        sma_on=settings['sma_on'],
        sma_length=settings['sma_length'],
        vwap_on=settings['vwap_on'],
        vwap_threshold=settings['vwap_threshold'],
        news_on=settings['news_on'],
        log_to_db=False
    )

    return render_template('backtest.html', settings=settings, trades=trades, net_return=net_return)

    # 4) Pass them back into the template for pre‐checking
    bt_settings = {
        "sma_on":   bt_sma_on,
        "sma_len":  bt_sma_len,
        "vwap_on":  bt_vwap_on,
        "vwap_thr": bt_vwap_thr,
        "news_on":  bt_news_on
    }

    return render_template(
        "backtest.html",
        trades      = trades,
        pnl         = pnl,
        bt_settings = bt_settings
    )




@app.route('/config')
def config():
    config = {}
    config_clean = {
        k: str(v) if isinstance(v, timedelta) else v
        for k, v in config.items()
    }
    return render_template('config.html', config=config_clean)


### ────────────── SIMULATION ────────────── ###

@app.route('/reset_simulation', methods=['POST'])
def reset_simulation():
    success = nuke_simulation_db()
    if success:
        return "Simulation reset!", 200
    else:
        return "Failed to reset simulation database.", 500


@app.route('/simulation')
def simulation():
    # Default fallback values if something goes wrong
    cash               = 0.0
    unrealized_pnl     = 0.0
    realized_pnl       = 0.0
    formatted_holdings = []
    formatted_trades   = []

    try:
        # 1) Current cash & realized P/L
        cash          = get_cash()
        realized_pnl  = get_realized_pl()

        # 2) Gather and format holdings
        raw_holdings = get_holdings()
        unrealized_pnl = 0.0
        for h in raw_holdings:
            unrealized_pnl += h['total_gain']
            formatted_holdings.append({
                'symbol':     h['symbol'],
                'last_price': h['last_price'],
                'change':     h['change'],
                'change_pct': h['change_pct'],
                'qty':        h['qty'],
                'price_paid': h['price_paid'],
                'day_gain':   h['day_gain'],
                'total_gain': h['total_gain'],
                'value':      h['value']
            })

        # 3) Gather and format trade history
        raw_trades = get_trades()
        for t in raw_trades:
            pl_display = f"${t['pnl']:.2f}" if t['pnl'] is not None else "-"
            formatted_trades.append({
                'time':   t['trade_time'],
                'symbol': t['symbol'],
                'action': t['action'],
                'qty':    t['qty'],
                'price':  f"${t['price']:.2f}",
                'pl':     pl_display
            })

    except Exception as e:
        import traceback; traceback.print_exc()
        print(f"[Simulation Error] {e}")

    return render_template(
        'simulation.html',
        cash=cash,
        unrealized_pnl=unrealized_pnl,
        realized_pnl=realized_pnl,
        holdings=formatted_holdings,
        history=formatted_trades
    )


@app.route("/simulation/buy", methods=["POST"])
def simulation_buy():
    data = request.get_json()
    symbol = data.get("symbol")
    qty    = int(data.get("qty", 0))
    if not symbol or qty <= 0:
        return jsonify({"error": "Invalid symbol or quantity"}), 400

    try:
        price = get_etrade_price(symbol)
        buy_stock(symbol, qty, price)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

    return jsonify({"success": True, "cash": get_cash()}), 200


@app.route("/simulation/sell", methods=["POST"])
def simulation_sell():
    data = request.get_json()
    symbol = data.get("symbol")
    qty    = int(data.get("qty", 0))
    if not symbol or qty <= 0:
        return jsonify({"error": "Invalid symbol or quantity"}), 400

    try:
        price = get_etrade_price(symbol)
        sell_stock(symbol, qty, price)
    except Exception as e:
        return jsonify({"error": str(e)}), 400

    return jsonify({
        "success": True,
        "cash": get_cash(),
        "realized_pl": get_realized_pl()
    }), 200


@app.route('/news/<symbol>')
def news_for_symbol(symbol):
    headlines = fetch_latest_headlines(symbol)
    sentiment = news_sentiment(symbol)
    return jsonify({'headlines': headlines, 'sentiment': sentiment})


### ────────────── SINGLE INDEX ROUTE (ALERTS + INDICATOR SETTINGS) ────────────── ###

from flask import redirect, url_for, render_template
from services.alert_service import get_alerts
@app.route('/', methods=['GET', 'POST'])
def index():
    # 1) Read on/off toggles
    sma_on   = (request.args.get('sma_on')   == 'on')
    rsi_on   = (request.args.get('rsi_on')   == 'on')
    macd_on  = (request.args.get('macd_on')  == 'on')
    bb_on    = (request.args.get('bb_on')    == 'on')
    vol_on   = (request.args.get('vol_on')   == 'on')
    vwap_on  = (request.args.get('vwap_on')  == 'on')
    news_on  = (request.args.get('news_on')  == 'on')
    print("VWAP_ON:", vwap_on, "NEWS_ON:", news_on)
    # 2) Read numeric filter values
    sma_length     = int(request.args.get('sma_length',     20))
    rsi_len        = int(request.args.get('rsi_len',        14))
    rsi_overbought = int(request.args.get('rsi_overbought', 70))
    rsi_oversold   = int(request.args.get('rsi_oversold',   30))
    macd_fast      = int(request.args.get('macd_fast',      12))
    macd_slow      = int(request.args.get('macd_slow',      26))
    macd_signal    = int(request.args.get('macd_signal',    9))
    bb_length      = int(request.args.get('bb_length',      20))
    bb_std         = float(request.args.get('bb_std',       2.0))
    vol_multiplier = float(request.args.get('vol_multiplier', 1.0))
    vwap_threshold = float(request.args.get('vwap_threshold', 0.0))

    # 3) Load alerts & compute how many matched
    alerts = get_alerts()
    match_count = len(alerts)

    # 4) Persist *all* settings, in the exact order your service expects:
    save_indicator_settings(
        match_count,
        sma_on,     sma_length,
        rsi_on,     rsi_len,        rsi_overbought,    rsi_oversold,
        macd_on,    macd_fast,      macd_slow,         macd_signal,
        bb_on,      bb_length,      bb_std,
        vol_on,     vol_multiplier,
        vwap_on,    vwap_threshold,
        news_on
    )

    # 5) Read them back so template can pre-select everything
    settings = get_all_indicator_settings()


    # 6) Render your alerts page
    return render_template(
        'alerts.html',
        alerts=alerts,
        settings=settings,
        match_count=match_count
    )




if __name__ == '__main__':
    app.run(debug=True)
