import sqlite3
import matplotlib
# Use the Agg backend so matplotlib never tries to open a GUI
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import io
from datetime import datetime

# Database paths
ALERTS_DB = 'alerts.db'
DB_PATH = 'alerts.db'

# ----------------------------------------------------------------------------
# Indicator Settings Table (run once via init script):
#
# CREATE TABLE IF NOT EXISTS indicator_settings (
#     id                INTEGER PRIMARY KEY CHECK(id = 1),
#     match_count       INTEGER NOT NULL DEFAULT 1,
#     sma_on            INTEGER NOT NULL DEFAULT 1,
#     sma_length        INTEGER NOT NULL DEFAULT 20,
#     rsi_on            INTEGER NOT NULL DEFAULT 1,
#     rsi_len           INTEGER NOT NULL DEFAULT 14,
#     rsi_overbought    INTEGER NOT NULL DEFAULT 70,
#     rsi_oversold      INTEGER NOT NULL DEFAULT 30,
#     macd_on           INTEGER NOT NULL DEFAULT 0,
#     macd_fast         INTEGER NOT NULL DEFAULT 12,
#     macd_slow         INTEGER NOT NULL DEFAULT 26,
#     macd_signal       INTEGER NOT NULL DEFAULT 9,
#     bb_on             INTEGER NOT NULL DEFAULT 0,
#     bb_length         INTEGER NOT NULL DEFAULT 20,
#     bb_std            REAL    NOT NULL DEFAULT 2.0,
#     vol_on            INTEGER NOT NULL DEFAULT 0,
#     vol_multiplier    REAL    NOT NULL DEFAULT 1.0,
#     vwap_on           INTEGER NOT NULL DEFAULT 1,
#     vwap_threshold    REAL    NOT NULL DEFAULT 0.5,
#     news_on           INTEGER NOT NULL DEFAULT 0,
#     rsi_slope_on      INTEGER NOT NULL DEFAULT 0,
#     macd_hist_on      INTEGER NOT NULL DEFAULT 0,
#     bb_breakout_on    INTEGER NOT NULL DEFAULT 0
# );
# INSERT OR IGNORE INTO indicator_settings (id) VALUES (1);
# ---------------------------------------------------------------------------

def save_indicator_settings(
    match_count,
    sma_on,     sma_length,
    rsi_on,     rsi_len,      rsi_overbought, rsi_oversold,
    macd_on,    macd_fast,    macd_slow,     macd_signal,
    bb_on,      bb_length,    bb_std,
    vol_on,     vol_multiplier,
    vwap_on,    vwap_threshold,
    news_on,
    rsi_slope_on, macd_hist_on, bb_breakout_on
):
    """
    Insert or update the single row (id=1) in indicator_settings with all parameters.
    """
    conn = sqlite3.connect(DB_PATH, timeout=30)
    conn.execute("PRAGMA journal_mode = WAL;")
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO indicator_settings (id) VALUES (1);")
    cur.execute(
        """
        UPDATE indicator_settings SET
            match_count      = ?,
            sma_on           = ?, sma_length      = ?,
            rsi_on           = ?, rsi_len         = ?, rsi_overbought = ?, rsi_oversold = ?,
            macd_on          = ?, macd_fast       = ?, macd_slow      = ?, macd_signal  = ?,
            bb_on            = ?, bb_length      = ?, bb_std         = ?,
            vol_on           = ?, vol_multiplier = ?,
            vwap_on          = ?, vwap_threshold = ?,
            news_on          = ?,
            rsi_slope_on     = ?, macd_hist_on   = ?, bb_breakout_on = ?
        WHERE id = 1;
        """,
        (
            match_count,
            int(sma_on),    sma_length,
            int(rsi_on),    rsi_len,        rsi_overbought,   rsi_oversold,
            int(macd_on),   macd_fast,      macd_slow,        macd_signal,
            int(bb_on),     bb_length,      bb_std,
            int(vol_on),    vol_multiplier,
            int(vwap_on),   vwap_threshold,
            int(news_on),
            int(rsi_slope_on), int(macd_hist_on), int(bb_breakout_on)
        )
    )
    conn.commit()
    conn.close()


def get_all_indicator_settings():
    """
    Fetch the single row (id=1) of indicator_settings,
    merge with defaults, and convert toggles to bool.
    """
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    row = conn.execute(
        "SELECT * FROM indicator_settings WHERE id = 1;"
    ).fetchone()
    conn.close()

    defaults = {
        'match_count':     0,
        'sma_on':          True,  'sma_length':     20,
        'rsi_on':          True,  'rsi_len':        14,
        'rsi_overbought':  70,    'rsi_oversold':   30,
        'macd_on':         False, 'macd_fast':      12,
        'macd_slow':       26,    'macd_signal':    9,
        'bb_on':           False, 'bb_length':      20,
        'bb_std':          2.0,
        'vol_on':          False, 'vol_multiplier': 1.0,
        'vwap_on':         True,  'vwap_threshold': 0.5,
        'news_on':         False,
        'rsi_slope_on':    False, 'macd_hist_on':   False, 'bb_breakout_on': False
    }

    if not row:
        return defaults

    settings = defaults.copy()
    for key in row.keys():
        if key in settings:
            settings[key] = row[key]

    for flag in [
        'sma_on', 'rsi_on', 'macd_on', 'bb_on', 'vol_on',
        'vwap_on', 'news_on', 'rsi_slope_on', 'macd_hist_on', 'bb_breakout_on'
    ]:
        settings[flag] = bool(settings.get(flag, False))

    settings['match_count'] = int(settings.get('match_count', 0))
    return settings


# Alias for external import
get_indicator_settings = get_all_indicator_settings


def generate_sparkline(prices):
    """
    Return a tiny black-background sparkline (yellow line) as SVG.
    """
    fig, ax = plt.subplots(figsize=(2.0, 0.4), dpi=100)
    fig.patch.set_facecolor('black')
    ax.set_facecolor('black')
    ax.plot(prices, color='yellow', linewidth=1.25)
    ax.axis('off')

    buf = io.BytesIO()
    fig.savefig(buf, format='svg', bbox_inches='tight', pad_inches=0, transparent=True)
    plt.close(fig)

    svg = buf.getvalue().decode().split('<svg', 1)[1]
    return f'<svg{svg}'


def get_active_alerts():
    """
    Return list of dicts for alerts where cleared=0, deduped by symbol.
    """
    conn = sqlite3.connect(ALERTS_DB)
    c = conn.cursor()
    c.execute(
        "SELECT id, symbol, name, price, vwap, vwap_diff, triggers, sparkline, timestamp"
        " FROM alerts WHERE cleared=0 ORDER BY timestamp DESC"
    )
    rows = c.fetchall()
    columns = [d[0] for d in c.description]
    conn.close()

    seen, alerts = set(), []
    from services.news_service import fetch_latest_headlines
    for row in rows:
        sym = row[1]
        if sym in seen: continue
        seen.add(sym)
        d = dict(zip(columns, row))
        d['has_news'] = bool(fetch_latest_headlines(sym))
        alerts.append(d)
    return alerts


def insert_alert(symbol, price, timestamp, name, vwap, vwap_diff, triggers, sparkline):
    """Insert a new alert, deleting any existing for the symbol."""
    conn = sqlite3.connect(ALERTS_DB)
    c = conn.cursor()
    c.execute("DELETE FROM alerts WHERE symbol=?", (symbol,))
    c.execute(
        "INSERT INTO alerts"
        " (symbol, price, timestamp, name, vwap, vwap_diff, triggers, sparkline, cleared)"
        " VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0)",
        (symbol, price, timestamp, name, vwap, vwap_diff, triggers, sparkline)
    )
    conn.commit()
    conn.close()


def mark_alert_cleared(alert_id):
    conn = sqlite3.connect(ALERTS_DB)
    conn.execute("UPDATE alerts SET cleared=1 WHERE id=?", (alert_id,))
    conn.commit()
    conn.close()


def clear_all_alerts():
    conn = sqlite3.connect(ALERTS_DB)
    conn.execute("UPDATE alerts SET cleared=1")
    conn.commit()
    conn.close()


def clear_alerts_by_filter(filter_type, value):
    conn = sqlite3.connect(ALERTS_DB)
    c = conn.cursor()
    if filter_type == 'symbol':
        c.execute("UPDATE alerts SET cleared=1 WHERE symbol=?", (value,))
    else:
        c.execute("UPDATE alerts SET cleared=1 WHERE triggers LIKE ?", (f"%{value}%",))
    conn.commit()
    conn.close()


def clear_alert_by_id(alert_id):
    conn = sqlite3.connect(ALERTS_DB)
    conn.execute("DELETE FROM alerts WHERE id=?", (alert_id,))
    conn.commit()
    conn.close()

# Expose alias
get_alerts = get_active_alerts
