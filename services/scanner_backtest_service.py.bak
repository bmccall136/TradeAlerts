import os
import sqlite3
import json
import logging
from datetime import datetime

import yfinance as yf
import pandas as pd
from services.news_service import fetch_latest_headlines

logger = logging.getLogger(__name__)
BACKTEST_DB = os.path.join(os.getcwd(), "backtest.db")

def _has_headlines(src):
    if hasattr(src, 'empty'):
        return not src.empty
    try:
        return len(src) > 0
    except:
        return False


def calculate_indicators(df):
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    # rename close
    close = df['Close'] if 'Close' in df.columns else df.iloc[:, 3]
    if isinstance(close, pd.DataFrame):
        close = close.iloc[:, 0]
    df['Close'] = close.astype(float)
    # RSI
    delta = close.diff()
    gain = delta.clip(lower=0).rolling(14).mean()
    loss = (-delta.clip(upper=0)).rolling(14).mean()
    df['RSI'] = 100 - (100 / (1 + gain / loss))
    # MACD
    ema_fast = close.ewm(span=12, adjust=False).mean()
    ema_slow = close.ewm(span=26, adjust=False).mean()
    df['MACD'] = ema_fast - ema_slow
    df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    # Bollinger
    mb = close.rolling(20).mean()
    std20 = close.rolling(20).std()
    df['MB'], df['UB'], df['LB'] = mb, mb + 2*std20, mb - 2*std20
    return df


def log_backtest_run(config, summary):
    conn = sqlite3.connect(BACKTEST_DB)
    c = conn.cursor()
    c.execute(
        """
        INSERT INTO backtest_runs (timestamp, config_json, summary_json)
        VALUES (?, ?, ?)
        """,
        (
            datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'),
            json.dumps(config),
            json.dumps(summary)
        )
    )
    run_id = c.lastrowid
    conn.commit()
    conn.close()
    return run_id


def log_backtest_trade(run_id, symbol, action, price, qty, trade_time, pnl):
    conn = sqlite3.connect(BACKTEST_DB)
    c = conn.cursor()
    c.execute(
        """
        INSERT INTO backtest_trades (run_id, symbol, action, price, qty, trade_time, pnl)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """,
        (run_id, symbol, action, price, qty, str(trade_time), pnl)
    )
    conn.commit()
    conn.close()


def backtest(
    symbol,
    start_date,
    end_date,
    initial_cash,
    max_trade_amount,
    sma_on=False,
    vwap_on=False,
    news_on=False,
    log_to_db=False,
    **kwargs
):

    # allow dashboard override of per‐stock max
    if max_trade_per_stock is not None:
        max_trade_amount = max_trade_per_stock

    # prepare logging
    run_id = None
    if log_to_db:
        run_id = log_backtest_run(
            {"symbol":symbol, "start_date":start_date, "end_date":end_date},
            {}
        )

    # fetch data
    yf_sym = symbol.replace('.', '-')
    df = yf.Ticker(yf_sym).history(
        start=start_date, end=end_date, interval='1d', auto_adjust=False
    )
    if df is None or df.empty:
        return [], 0.0

    df = calculate_indicators(df)
    tp = (df['High'] + df['Low'] + df['Close'])/3
    vwap = (tp*df['Volume']).cumsum()/df['Volume'].cumsum()
    df['VWAP_Diff'] = df['Close'] - vwap

    trades = []
    cash, position = initial_cash, 0
    in_position = False
    entry_idx = None

    for i in range(1, len(df)):
        price = df['Open'].iat[i] if 'Open' in df else df['Close'].iat[i]

        # entry filters
        if sma_on:
            sma = df['Close'].iloc[:i+1].rolling(sma_length).mean().iat[-1]
            if price <= sma: continue
        if vwap_on and df['VWAP_Diff'].iat[i] < vwap_threshold: continue
        if news_on and not _has_headlines(fetch_latest_headlines(symbol)): continue

        # try entry
        if (not single_entry_only or not in_position):
            qty = int(min(cash, max_trade_amount) // price)
            if qty > 0:
                cash -= qty*price
                position += qty
                in_position = True
                entry_idx = i
                trades.append(dict(symbol=symbol, action='BUY',
                                   date=str(df.index[i]), qty=qty,
                                   price=price, pnl=0.0))
                if log_to_db and run_id:
                    log_backtest_trade(run_id, symbol, 'BUY', price, qty, df.index[i], 0.0)

        # trailing‐stop exit
        if in_position and use_trailing_stop:
            highest = df['High'].iloc[entry_idx:i+1].max()
            if price <= highest*(1-trailing_stop_pct):
                cash += position*price
                pnl = cash - initial_cash
                trades.append(dict(symbol=symbol, action='SELL',
                                   date=str(df.index[i]), qty=position,
                                   price=price, pnl=round(pnl,2)))
                if log_to_db and run_id:
                    log_backtest_trade(run_id, symbol, 'SELL', price, position, df.index[i], round(pnl,2))
                in_position = False

        # time‐stop exit
        if in_position and sell_after_days is not None:
            days_held = (df.index[i] - df.index[entry_idx]).days
            if days_held >= sell_after_days:
                cash += position*price
                pnl = cash - initial_cash
                trades.append(dict(symbol=symbol, action='SELL',
                                   date=str(df.index[i]), qty=position,
                                   price=price, pnl=round(pnl,2)))
                if log_to_db and run_id:
                    log_backtest_trade(run_id, symbol, 'SELL', price, position, df.index[i], round(pnl,2))
                in_position = False

    # final liquidation if still in
    if in_position and position>0:
        final_price = df['Close'].iat[-1]
        cash += position*final_price
        pnl = cash - initial_cash
        trades.append(dict(symbol=symbol, action='SELL',
                           date=str(df.index[-1]), qty=position,
                           price=final_price, pnl=round(pnl,2)))
        if log_to_db and run_id:
            log_backtest_trade(run_id, symbol, 'SELL', final_price, position, df.index[-1], round(pnl,2))

    return trades, float(cash-initial_cash)

# alias
backtest_scanner = backtest
