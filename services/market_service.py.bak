# File: services/market_service.py

import logging
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FuturesTimeout
from datetime import datetime
import yfinance as yf
import pandas as pd
import os

from services.etrade_service import fetch_etrade_quote
from services.alert_service import (
    get_all_indicator_settings,
    insert_alert,
    generate_sparkline
)
from services.indicators import (
    calculate_macd,
    compute_rsi,
    compute_bollinger,
    compute_sma
)

logger = logging.getLogger(__name__)


def fetch_data_with_timeout(sym, period='1d', interval='5m', timeout=10):
    """
    Attempt to fetch intraday data (1d/5m) from Yahoo Finance with a timeout.
    Returns a Pandas DataFrame or None on failure.
    """
    def _fetch():
        try:
            return yf.download(
                sym,
                period=period,
                interval=interval,
                progress=False,
                threads=False
            )
        except Exception as e:
            logger.error(f"[ERROR] Yahoo download {sym} failed: {e}")
            return None

    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(_fetch)
        try:
            return future.result(timeout=timeout)
        except FuturesTimeout:
            logger.error(f"[ERROR] Yahoo download {sym} timed out after {timeout}s")
            return None


def analyze_symbol(sym):
    """
    1) Read all 12 indicator settings from DB:
       - match_count (1..6)
       - sma_length
       - rsi_len, rsi_overbought, rsi_oversold
       - macd_fast, macd_slow, macd_signal
       - bb_length, bb_std
       - vol_multiplier
       - vwap_threshold
       - news_on (boolean)
    2) Download 1d/5m bars from Yahoo
    3) Fetch current E*TRADE price
    4) Compute each indicator with those parameters:
       • SMA (length = sma_length)
       • RSI (period=rsi_len, thresholds = rsi_overbought/oversold)
       • MACD (fast, slow, signal)
       • BB (window=bb_length, std=bb_std)
       • Volume trigger (vol >= vol_multiplier * avg(volume, 20))
       • VWAP trigger (price - VWAP >= vwap_threshold)
    5) Count how many of the SIX “primary” triggers are true:
       [SMA, RSI, MACD, BB, Volume, VWAP]
       If count < match_count: skip; else insert alert.
    """

    # ── A) Load settings from DB ──
    settings = get_all_indicator_settings()
    match_count    = settings['match_count']
    sma_length     = settings['sma_length']
    rsi_len        = settings['rsi_len']
    rsi_ob         = settings['rsi_overbought']
    rsi_os         = settings['rsi_oversold']
    macd_fast      = settings['macd_fast']
    macd_slow      = settings['macd_slow']
    macd_signal    = settings['macd_signal']
    bb_length      = settings['bb_length']
    bb_std         = settings['bb_std']
    vol_multiplier = settings['vol_multiplier']
    vwap_threshold = settings['vwap_threshold']
    news_on        = settings['news_on']

    # ── B) Download price data ──
    df = fetch_data_with_timeout(sym)
    if df is None or df.empty:
        logger.error(f"[SKIP] {sym}: no intraday data")
        return None

    # ── C) Fetch last price from E*TRADE ──
    try:
        etrade_price = fetch_etrade_quote(sym)
    except Exception as e:
        logger.error(f"[SKIP] {sym}: E*TRADE error {e}")
        return None
    if not etrade_price or etrade_price == 0.0:
        logger.error(f"[SKIP] {sym}: invalid E*TRADE price")
        return None
    logger.info(f"{sym}: Price = ${etrade_price:.2f}")

    # ── D) Fetch company name ──
    try:
        info = yf.Ticker(sym).info
        company_name = info.get('longName') or info.get('shortName') or sym
    except:
        company_name = sym

    # ── E) Compute each indicator with user settings ──

    # 1) SMA (period = sma_length)
    price_series = df['Close']
    sma_val = compute_sma(price_series, length=sma_length)

    # 2) RSI (period = rsi_len)
    rsi_series = compute_rsi(price_series, period=rsi_len)
    rsi_val = rsi_series.iloc[-1]

    # 3) MACD (fast/slw/sig)
    macd_line, sig_line = calculate_macd(
        price_series,
        fast=macd_fast,
        slow=macd_slow,
        signal=macd_signal
    )

    # 4) Bollinger Bands (window = bb_length, num_std = bb_std)
    bb_up, bb_mid, bb_dn = compute_bollinger(
        price_series,
        window=bb_length,
        num_std=bb_std
    )

    # 5) Volume trigger: check vol >= vol_multiplier × avg(vol,20)
    vol         = df['Volume'].iloc[-1]
    avg_vol_20  = df['Volume'].rolling(window=20).mean().iloc[-1]
    vol_trigger = (vol >= vol_multiplier * avg_vol_20)

    # 6) VWAP trigger: price - VWAP >= vwap_threshold
    df['TypicalPrice']   = (df['High'] + df['Low'] + df['Close']) / 3
    df['TPV']            = df['TypicalPrice'] * df['Volume']
    df['CumulativeTPV']  = df['TPV'].cumsum()
    df['CumulativeVol']  = df['Volume'].cumsum()
    df['VWAP']           = df['CumulativeTPV'] / df['CumulativeVol']
    latest_vwap          = df['VWAP'].iloc[-1]
    vwap_diff_value      = etrade_price - latest_vwap
    vwap_trigger         = (vwap_diff_value >= vwap_threshold)

    # ── F) Count how many of the SIX “primary” indicators triggered ──
    primary_triggers = []
    price = price_series.iloc[-1]

    # 1) SMA
    if price > sma_val:
        primary_triggers.append('SMA')

    # 2) RSI
    if rsi_val > rsi_ob:
        primary_triggers.append('RSI_OB')
    elif rsi_val < rsi_os:
        primary_triggers.append('RSI_OS')

    # 3) MACD
    if macd_line.iloc[-1] > sig_line.iloc[-1]:
        primary_triggers.append('MACD')

    # 4) BB
    if price > bb_up.iloc[-1] or price < bb_dn.iloc[-1]:
        primary_triggers.append('BB')

    # 5) Volume
    if vol_trigger:
        primary_triggers.append('VOLUME')

    # 6) VWAP
    if vwap_trigger:
        primary_triggers.append('VWAP')

    if len(primary_triggers) < match_count:
        logger.info(
            f"[SKIP] {sym}: {len(primary_triggers)} < {match_count} primary indicators"
        )
        return None

    # ── G) Build the full “triggers” list for display/storage ──
    display_triggers = []
    # SMA
    if price > sma_val:
        display_triggers.append('SMA 🟡')
    # RSI
    if rsi_val > rsi_ob:
        display_triggers.append('RSI 📈')
    elif rsi_val < rsi_os:
        display_triggers.append('RSI 📉')
    # MACD
    if macd_line.iloc[-1] > sig_line.iloc[-1]:
        display_triggers.append('MACD 🚀')
    # BB
    if price > bb_up.iloc[-1] or price < bb_dn.iloc[-1]:
        display_triggers.append('BB 📈')
    # Volume
    if vol_trigger:
        display_triggers.append(f'VOL 🔊 ({vol/avg_vol_20:.2f}×)')
    # VWAP
    if vwap_trigger:
        display_triggers.append(f'VWAP+ (${vwap_diff_value:.2f})')

    # ── H) Optional: News if enabled ──
    if news_on:
        from services.news_service import fetch_sentiment_for
        try:
            sentiment = fetch_sentiment_for(sym)
            if sentiment > 0.2 or sentiment < -0.2:
                display_triggers.append('News 📰')
        except Exception as e:
            logger.error(f"[WARN] {sym}: News fetch failed: {e}")

    # ── I) Generate sparkline, insert alert ──
    spark_svg = generate_sparkline(price_series.tolist())
    alert_payload = {
        'symbol':    sym,
        'price':     etrade_price,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'name':      company_name,
        'vwap':      round(latest_vwap, 2),
        'vwap_diff': round(vwap_diff_value, 2),
        'triggers':  ",".join(display_triggers),
        'sparkline': spark_svg
    }
    insert_alert(**alert_payload)
    logger.info(f"[ALERT] {sym}: {display_triggers}")

    return alert_payload


# ────────────────────────────────────────────────────────────────────────────────

def get_symbols():
    """
    Returns a list of symbols to scan. First tries to read 'symbols.txt' (one ticker per line).
    If 'symbols.txt' does not exist or is empty, falls back to a small example list.
    """
    fallback = ['AAPL', 'MSFT', 'GOOG', 'TSLA']  # replace with whatever you like

    path = os.path.join(os.path.dirname(__file__), '..', 'symbols.txt')
    try:
        with open(path, 'r') as f:
            lines = [line.strip().upper() for line in f if line.strip()]
            return lines if lines else fallback
    except FileNotFoundError:
        return fallback
